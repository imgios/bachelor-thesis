\phantomsection
\chapter{Dependensee}
\markboth{Dependensee}{}
\label{cap5:dependensee}
% [titolo ridotto se non ci dovesse stare] 
\begin{center}
    \includegraphics[width=.5\columnwidth]{capitoli/figure/logo_dependensee}
\end{center}

In questo capitolo verr\`{a} introdotto \textit{Dependensee}, lo strumento sviluppato per la visualizzazione di insiemi minimali di \acrlong{rfds} mediante l'implementazione della metafora visiva descritta nel paragrafo \ref{section:visual_rep_metaphore}. Tale strumento facilita la visualizzazione delle \acrlong{rfds} minimali e rappresenta diverse loro caratteristiche, facilitando l'utente nell'analisi visiva degli insiemi composti da queste.

\section{Introduzione} %\label{1sec:scopo}
Dependensee \`{e} una web application che mira a rappresentare visivamente grandi insiemi minimali di \acrlong{rfds}, per permettere all'utente che lo utilizza una rapida e semplice analisi visiva di questi insiemi. Ci\`{o} avviene attraverso una metafora intuitiva, descritta in dettaglio nel capitolo \ref{section:visual_rep_metaphore}, la quale fornisce una panoramica generale sull'insieme, esplicitando dettagli e caratteristiche delle \acrlong{rfds} che formano l'insieme. Per quanto concerne lo sviluppo sono state utilizzate diverse tecnologie, le quali verranno esposte pi\'{u} nel dettaglio nel paragrafo \ref{tecnologie}, tra cui \textit{D3.js}. Il tool trasforma i dati testuali in grafici immediati tramite la manipolazione di questa libreria, la quale permette di costruire grafici complessi in formato SVG. Dependensee \`{e} stato sviluppato con l'obiettivo di semplificare e velocizzare l'analisi dei dataset, infatti, presenta un'interfaccia semplice e pulita, che non richiedere particolari conoscenze. Ci\`{i} \`{e} vero anche per il suo funzionamento, di fatti sono poche le azioni da eseguire per analizzare un dataset ed ottenere il grafico relativo, e per l'interpretazione della rappresentazione grafica dei risultati.

\section{Tecnologie utilizzate}\label{tecnologie}
Per lo sviluppo di Dependensee \`{e} stato utilizzato il pattern Model-View-Controller (MVC), in modo tale da separare la logica di presentazione con la logica di business, con le seguenti tecnologie:
\begin{itemize}
    \item TypeScript,
    \item Angular,
    \item Ionic,
    \item D3.js,
    \item Node.js.
\end{itemize}
% -- Pattern MVC
\begin{figure}[ht]
    \centering
    \includegraphics[width=.5\columnwidth]{capitoli/figure/mvc}
    \caption{Pattern Model-View-Controller (MVC).}
    \label{fig:pattern_mvc}
\end{figure}
% -- End Pattern MVC
Il pattern MVC \`{e} un pattern architetturale in grado di separare la logica di presentazione con la logica di business. Esso \`{e} composto da tre componenti diversi tra loro: Model, View e Controller.
Il Model fornisce i metodi per accedere ai dati utili all'applicazione, la View visualizza i dati contenuti nel Model e si occupa dell'interazione con gli utenti, mentre il Controller riceve i comandi dall'utente attraverso la View e li attua modificando lo stato degli altri due componenti. Il pattern appena descritto lo troviamo anche in Angular, evoluzione di AngularJS, il quale \`{e} un framework open source per lo sviluppo di applicazioni web. Le applicazioni sviluppate mediante Angular sono supportate su tutti i principali web browser, da computer a mobile, e vengono eseguite internamente nel browser dopo essere state scaricate dal server. Tale framework \`{e} sviluppato da Google ed il linguaggio di programmazione utilizzato \`{e} TypeScript, lo troviamo alla base di Ionic e costituisce il lato back-end dell'applicazione. TypeScript \`{e} un linguaggio di programmazione open source sviluppato dalla Microsoft, nato dal crescente bisogno di un linguaggio front-end per lo sviluppo di applicazioni JavaScript su larga scala. Si tratta, infatti, di un superset di JavaScript che basa le sue caratteristiche su ECMAScript 6. Esso estende la sintassi di JavaScript, in questo modo qualunque programma scritto in JavaScript \`{e} anche in grado di essere eseguito con TypeScript senza alcuna modifica. Inoltre, \`{e} stato progettato principalmente per lo sviluppo di applicazioni e viene successivamente ricompilato in JavaScript per poter essere interpretato in qualsiasi web browser e su qualsiasi sistema operativo. Ionic \`{e} un Software Development Kit (SDK) open source completo per lo sviluppo di app ibride e costituisce principalmente il lato front-end dell'applicazione. Esso fornisce strumenti e servizi per lo sviluppo di applicazioni desktop, mobile e Progressive Web Apps, basate sulle pratiche e tecnologie moderne di sviluppo web, utilizzando tecnologie come CSS, HTML5 e SASS. In particolare, possono essere sviluppate applicazioni mobile con le suddette tecnologie web ed \`{e} possibile, successivamente, distribuirle tramite Cordova o Capacitor sui vari App Store nativi. D3.js \`{e} una libreria sviluppata in JavaScript per creare visualizzazioni dinamiche ed interattive partendo da dati organizzati, visibili attraverso un comune browser. Per fare ci\`{o} si serve largamente degli standard web: SVG, HTML5, CSS. Diversamente da molte altre librerie, essa permette un ottimo controllo e resa visiva sul risultato finale. D3.js, incorporata in una pagina web HTML, utilizza funzioni JavaScript prefatte per selezionare elementi del DOM, creare elementi SVG, aggiungergli uno stile grafico, oppure transizioni, effetti di movimento e/o tooltip. In questo modo grandi collezioni di dati possono essere facilmente convertiti in oggetti SVG usando semplici funzioni della libreria e generare cos\`{i} ricche rappresentazioni grafiche di numeri, testi, mappe e diagrammi. I dati utilizzati possono essere in diversi formati, i pi\`{u} comuni sono JSON e CSV, ma, se necessario, si possono scrivere funzioni per leggere dati in altri formati. Il tutto viene eseguito su Node.js, una runtime di JavaScript open source multipiattaforma orientato agli oggetti per l'esecuzione di codice JavaScript. Node.js permette di implementare il cosiddetto paradigma \textit{"JavaScript everywhere"}, unificando lo sviluppo su un unico linguaggio di programmazione, ovvero JavaScript, sia per il lato client che per il lato server. Esso ha un'architettura orientata agli eventi che rende possibile l'I/O asincrono e migliora il throughput e la scalabilit\`{a} nelle applicazioni web con molte operazioni di input/output.

\section{Implementazione}
L'applicazione Dependensee \`{e} stata implementata sulla base del pattern MVC, descritto in precedenza, e si compone principalmente di:
\begin{itemize}
    \item Homepage,
    \item Visualize Page,
    \item Analyzer Service.
\end{itemize}
La prima componente, ovvero l'homepage, attualmente rimanda direttamente alla Visualize Page, di cui parleremo a breve. \`{E} necessario introdurre prima l'implementazione effettiva di una \acrlong{rfd} all'interno di Dependensee. Per l'implementazione delle \acrshort{rfds} \`{e} stata creata una classe, \texttt{RelaxedFunctionalDependence}, la quale definisce una \acrshort{rfd} come un oggetto con due attributi:
\begin{itemize}
    \item \texttt{lhs} \`{e} un array di tuple del tipo \texttt{[string,number]}, il quale contiene gli attributi del lato sinistro della \acrshort{rfd} con le relative thresholds,
    \item \texttt{rhs} \`{e} una tupla del tipo \texttt{[string,number]} che contiente l'attributo del lato destro della \acrshort{rfd} con la threshold relativa.
\end{itemize}
%Tra i metodi definiti troviamo, oltre al costruttore, ai getter ed ai setter:
%\begin{itemize}
    %\item \texttt{pushAttribute} che \`{e} il metodo con il quale \`{e} possibile inserire dei nuovi elementi all'interno dell'array \texttt{lhs},
    %\item \texttt{removeAttribute} che \`{e} il metodo con il quale \`{e} possibile rimuovere un elemento dall'array \texttt{lhs},
    %\item \texttt{contains} che, definito il lato e l'attributo della \acrshort{rfd}, ritorna l'elemento dell'array se l'attributo \`{e} presente nel lato indicato.
%\end{itemize}
Visualize Page \`{e} composta da due elementi: \texttt{visualize.page.html} che rappresenta la View per l'interazione con l'applicazione, \texttt{visualize.page.ts} che rappresenta il Model. Nella View \`{e} presente un'interfaccia semplice e pulita, dove \`{e} richiesto il dataset da analizzare in formato \texttt{.txt} e la threshold massima. Inoltre, sempre nella View, \`{e} presente un area di log a scomparsa dove \`{e} possibile leggere i messaggi di log ed un'area alla fine della pagina dove appare il grafico risultante dall'analisi. Il Model, ovvero \texttt{visualize.page.ts}, si interpone tra la View ed il Controller, utilizza i metodi dell'Analyzer Service per analizzare i dati e crearne poi un grafico da inserire all'interno della View in modo dinamico.\par
L'Analyzer Service rappresenta il Controller ed al suo interno vi sono due metodi principali chiamati dal Model: il primo \`{e} analyzeFile, si occupa di analizzare il dataset ricevuto in input e restituisce in output un oggetto \texttt{rfdSet}, il quale \`{e} un array del tipo \texttt{RelaxedFunctionalDependence} che contiene tutte le dipendenze riscontrare nel dataset, ed un oggetto \texttt{attributes}, il quale \`{e} un array di stringhe che contiene tutti gli attributi individuati nel dataset. Il suo funzionamento si basa sulla lettura del dataset, riga per riga, tramite un \texttt{FileReader} e, per ogni riga, si effettuano operazioni di divisione della stringa per individuare gli attributi su ambo i lati con le thresholds relative. Il secondo \`{e} retrieveData che, dati in input il set di \acrshort{rfds}, gli attributi del lato sinistro e del lato destro, la threshold massima e la cardinalit\`{a} massima, individua le \acrshort{rfds} valide e le restituisce come un oggetto JSON. Questo metodo viene richiamato per ogni sotto-matrice del grafico risultante in fase di creazione, ovvero per individuare i dati relativi ad ogni attributo visto sul lato sinistro per un fissato attributo sul lato destro. Per testare la validit\`{a} di una \acrshort{rfd}, il metodo verifica, in due cicli annidati che corrispondono alla threshold massima ed alla cardinalit\`{a} massima, prima che questa contenga gli attributi indicati in input per il lato sinitro e per il lato destro, poi verifica le thresholds e la cardinalit\`{a}. L'ultima fase di verifica consiste nella propagazione dei dati. La propagazione dei dati avviene in due casi: il primo caso si presenta quando esiste una \acrshort{rfd} con cardinalit\`{a} del lato sinistro minore ed una threshold maggiore dello stesso attributo presente sul lato sinistro, in questo caso tale \acrshort{rfd} viene propagata all'interno della matrice. Il secondo caso si presenta quando esiste una \acrshort{rfd} con cardinalit\`{a} del lato sinistro minore e threshold minima, ovvero pari a $0$. Anche in questo caso, il dato viene propagato all'interno della matrice.

\section{Funzionamento}
Dependensee mira alla semplicit\`{a} ed all'efficacia, ragion per cui presenta un'interfaccia pulita e molto semplice da utilizzare. Il deploy dell'applicazione pu\`{o} essere effettuato sia su server che in locale. Per effettuare il deploy in locale \`{e} necessario, come prerequisiti, avere Node.js, npm ed Ionic 4 sulla propria macchina. Successivamente, basta aprire la directory tramite bash e digitare il comando \texttt{ionic serve}, cos\`{i} da avviare un server in locale su tutte le interfacce di rete. Fatto ci\`{o}, baster\`{a} dirigersi all'indirizzo corrispondente al server avviato, in genere \texttt{http://localhost:8100}, per iniziare ad utilizzare Dependensee. Una volta aperto l'indirizzo nel browser, si presenter\`{a} un'interfaccia semplice ed immediata, come mostrato in Figura \ref{fig:dependensee_main_screen}, composta da:
\begin{itemize}
    \item un input per selezione il dataset da analizzare in formato \texttt{.txt},
    \item un input per indicare la threshold massima,
    \item un bottone per avviare l'analisi e generare il grafico relativo al dataset,
    \item una finestra nascosta di default che \`{e} possibile mostrare per leggere i messaggi di log generati da Dependensee.
\end{itemize}
% -- Main Screen
\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{capitoli/figure/dependensee_main_screen}
    \caption{Interfaccia di Dependensee.}
    \label{fig:dependensee_main_screen}
\end{figure}
% -- End Main Screen
Quindi, bisogna selezionare il dataset da analizzare in formato .txt, con la seguente struttura:
\begin{verbatim}
    B@4.0->F@4.0
    D@4.0->F@4.0
    C@4.0->F@4.0
    E@4.0->F@4.0
    G@4.0->F@4.0
    A@4.0->F@4.0
    A@2.0,B@0.0,C@0.0,D@4.0,E@2.0,F@2.0->G@2.0
    A@0.0,B@0.0,C@0.0,D@4.0,E@2.0,F@2.0->G@0.0
\end{verbatim}
dove le stringhe che precedono il simbolo \texttt{@} indicano gli attributi, i valori che vengono scritti dopo il simbolo \texttt{@} indicano le threshold relative agli attrubuti ed i simboli \texttt{->} dividono il lato sinistro della \acrshort{rfd} dal lato destro. Successivamente, bisogna inserire il valore massimo delle threshold e cliccare sul bottone per avviare l'analisi. Se i due campi di input non sono stati violati, allora Dependensee proceder\`{a} con l'analisi e visualizzer\`{a} un grafico relativo al dataset inserito, come mostrato in Figura \ref{fig:dependensee_dataset_analyzed}, altrimenti mostrer\`{a} un messaggio d'errore relativo al campo di input da modificare.
% -- Dataset Analyzed
\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{capitoli/figure/dependensee_analyzed_screen}
    \caption{Grafico generato da Dependensee relativo al dataset inserito in input.}
    \label{fig:dependensee_dataset_analyzed}
\end{figure}
% -- End Dataset Analyzed
Una volta ottenuta la rappresentazione grafica del dataset sar\`{a} possibile effettuare operazioni di zoom-in/out per visualizzarlo meglio e per concentrarsi in singole porzioni di esso, oppure sar\`{a} possibile analizzare un altro dataset cliccando sul bottone in alto.

\section{Interpretazione dei risultati}
Una volta analizzato un dato dataset, il tool proceder\`{a} alla creazione di un grafico colorato con le \acrlong{rfds} contenute nel dataset. Il grafico consiste in una matrice $n\times n$, dove $n$ \`{e} il numero di attributi presenti nel dataset. Gli attributi presenti sulle righe fanno riferimento alle \acrshort{rfds} in cui appare l'attributo in questione sul lato sinistro, mentre gli attributi presenti sulle colonne fanno riferimento alle \acrshort{rfds} in cui appare l'attributo in questione sul lato destro. La matrice \`{e} a sua volta composta da delle sotto-matrici, in cui gli elementi vengono rappresentati seguendo due metriche: cardinalit\`{a} del lato sinistro e threshold dell'attributo sul lato destro. Se ogni sotto-matrice viene vista come un piano cartesiano in due dimensioni, le ascisse rappresentano le thresholds del lato destro, mentre le ordinate rappresentano le cardinalit\`{a} del lato sinistro. I colori utilizzati per raffigurare gli elementi rappresentano la threshold dell'attributo sul lato sinistro e la threshold dell'attributo sul lato destro, rispettivamente il bordo ed il riempimento. Colori pi\`{u} intensi indicano thresholds pi\`{u} vicine o uguali a zero, mentre colori meno intensi indicano threshold pi\`{u} vicine o uguali al valore indicato in input. Ad esempio, se guardiamo il grafico della Figura \ref{fig:dependensee_dataset_analyzed} e consideriamo l'ultima riga e la prima colonna, questa sotto-matrice corrisponde alle \acrshort{rfds} aventi l'attributo \texttt{YEAR} sul lato sinistro e l'attributo \texttt{AUTHORS} sul lato destro. Guardandola possiamo notare l'esistenza di \acrshort{rfds} con cardinalit\`{a} maggiore uguale a $3$, con thresholds sull'attributo \texttt{AUTHORS} comprese tra $0$ e $3$ (inclusi) e thresholds sull'attributo \texttt{YEAR} uguali a $0$. Il colore grigio indica che non esistono \acrshort{rfds} con l'attributo \texttt{YEAR} sul lato sinistro, con l'attributo \texttt{AUTHORS} sul lato destro, con cardinalit\`{a} uguale a $0$ o $1$ e thresholds dell'attributo \texttt{AUTHORS} comprese tra $0$ e $3$.

%\section{Valutazione sperimentale}
%Per valutare l'efficacia dello strumento sono stati analizzati -tot- dataset diversi elencati in Tabella %\ref{table:stats_dataset}, ognuno con numero di \acrlong{rfds} diverso dall'altro.
%% -- TAB DATASET --
%\begin{table}[h!]
%\centering
%%\refstepcounter{table}
%\caption{Statistiche dei dataset considerati.}
%\label{table:stats_dataset}
%\begin{tabular}{|l|r|} 
%\hline
%\multicolumn{2}{|c|}{\textbf{Statistiche}}     \\ 
%\multicolumn{1}{|l}{\textbf{Dataset}} & \multicolumn{1}{l|}{\textbf{\#RFD}}  \\
%\hline
%A                                     & 1                                    \\
%b                                     & 2                                    \\
%c                                     & 3                                    \\
%\hline
%\end{tabular}
%\end{table}
%% -- END TAB DATASET --